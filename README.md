Pyc Disassem proejct
===============
This document explains the methodology of Pyc Disassem in order to prevent from attackers inject malicious corner case instruction sequences.

<!-- npm i -g markdown-toc; markdown-toc -i ota_app_system_document.md -->
<!-- toc -->

- [Introduction](#introduction)    
- [Project Overview](#project-overview)
- [Background](#background)
- [Issues](#issues)
- [Test and Result](#test-and-result)
- [Conclusion](#conclusion)
- [Reference](#reference)

<!-- tocstop -->

## Introduction

Today, a ton of application is realized by the interpreted programming language (e.g., Python, Java) devised by each provider. To analyze the applications based on the binary level research, the capabilities of disassembly play significant role in the situation where source codes are not available. In other word, the disassembly is the backbone in binary level vulnerability research [1],[2]. In order to analyze binary format files (e.g., pyc file), the disassembler can assume that the binary format files have underlying architecture [3]. However, when attackers inject malicious corner case instruction sequences [4],[5] to victim binary files, it makes difficult for researchers to analyze them with reverse engineering, ultimately destroying the assumed format of them. Figure 1 describes the difficulty of analysis in a system built by Python, which is caused by the malicious corner case instruction sequences.

<p align="center">
<img src="./img/Figure%201.png"><br>
<strong>Figure 1</strong>
<p>

To solve such problem, we present a methodology that modifies the corner case sequences and makes the disassembler recognize the modified files by using pyxasm [6], pyxdis [7], and uncompyle6 [8]. With the methodology, we aim to find injected corner case instruction sequences, to modify them, and to make disassembler recognize them correctly. By doing so, we expect that researchers and developers successfully analyze whether or not the applications are contaminated by attackers, what threat models does they employ, and how to protect the applications against them.

## Project Overview

<p align="center">
<img src="./img/Figure%202.png"><br>
<strong>Figure 2</strong>
<p>

Figure 2 pictures the whole concept of the project called ‘Python Decomplier’. The ‘Python Disasm’ module takes the ‘pyc’ files contaminated by attackers as an input. Xasm (pyxasm), yellow cylinder, provides functions that disassemble ‘pyc’ files to bytecode (binary format) and that reassemble the disassembled ‘pyc’ files to executable binary files. Xids, blue cylinder, offers libraries relevant to disassemble and reassemble input files. When the infected ‘pyc’ files are disassembled, the corner case instruction sequences and malicious code snippet will be detected and modified through reverse engineering. As a result, the contaminated input files will be correctly recognized by uncompyle6.

## Background

In this section, I will explain what I understand while performing the project. Figure 4 elaborates the format of ‘pyc’ file. The ‘pyc’ file be made of three parts broadly [9]. The magic byte (4 bytes), the field of 0 (4byte), timestamp (4byte), and the size of source code (4 byte) are placed at first on ‘pyc’ file. And then they are followed by ‘Metadata’, and it is finally followed by ‘Code Object’. ‘Code Object’ consists of several sub-objects as shown in Figure 3. Each object is recognized as each corresponding class in the byte format file. The interesting thing is that opcode is regarded as bytes class in the bytecode. 

<p align="center">
<img src="./img/Figure%203.png"><br>
<strong>Figure 3</strong>
<p>
    
Figure 4 presents the detailed ‘pyc’ file format. Each object has their own frame and a corresponding identifier (red color). For example, 0x63 means the start point of ‘Metadata’ and 0x73 means the start point of code object (co_code). The blue color represents the size of data included in their own frame, and the yellow color means opcode data. Each opcode can be interpreted by opcode table [10]. For example, 0x64 means LOAD_CONST and 0x84 means MAKE_FUNCTION.

<p align="center">
<img src="./img/Figure%204.png" height="500"><br>
<strong>Figure 4</strong>
<p>

## Issues

1) Duplicated and deleted method names<br>
When a ‘pyc’ file is disassembled via ‘pyxasm’ and ‘pyxdis’, a bytecode file is generated as an intermediate outcome (i.e., Test.pyasm in Figure 5). I found that a couple of method had not been disassembled correctly. One method name is duplicated and another method name is deleted, and I realized the reason why this issue occurs. Figure 5 explains the reason of this issue. Test.py file is a source code file, and Test.pyc file is generated by compiling Test.py. The listcomp, dictcomp, lambda, setcomp, and genexp library are used in the Def function(). They are provided by python library. When using such libraries, they are disassembled as a method in Test.pyasm file. However, when the Def function() is disassembled, it is disassembled with the library name used at the end of the Def function() instead of its own name. It actually causes for ‘pyxasm’ to incorrectly reassemble the Test.pyasm file. As a result, the resulting outcome failed to be recognized correctly by uncompyle6 and to run on Python Virtual Machine.

<p align="center">
<img src="./img/Figure%205.png"><br>
<strong>Figure 5</strong>
<p>
    
2) Ill-formed reassembled pyc file caused by dictionary accession violation<br>
I installed Python version 3.8.2 while performing the project. Whenever I tried to disassemble and reassemble a pyc file, it always caused ill-formed output file. To understand this problem, I analyzed the source code of ‘pyxasm’. 

<p align="center">
<img src="./img/Figure%206.png"><br>
<strong>Figure 6</strong>
<p>
    
<p align="center">
<img src="./img/Figure%207.png"><br>
<strong>Figure 7</strong>
<p>

Figure 6 is a part of the source code of ‘pyxasm’, and this part was the root cause of this issue. With Python version 3.8.2, code object is recognized as ‘class: xdis.codetype.code38.Code38’. But there is no any function to handle the Code38 class in Figure 6. Handling the class is processed with dictionary data structure in this project. In the dictionary data structure, there was no Code38 key and the corresponding value. As a result, when processing Code38 object, the Code38 object is disassembled with Python version 2 format. To solve this problem, I modified the source code as shown in Figure 7, and added a defense code snippet to protect such issue.

## Test and Result
In this section, I will summarize the test result about pyxasm, pyxdis, and uncompyle6 to determine whether or not these tools can be applied to our approach. The test procedure is as follows

1. Do disasm, and then reasm input file (test_pyc.pyc)<br>
2. Compare the execution of the input and output file (test_pyc.pyc, test_pyc.pyc.pyc)<br>
3. Check errors during No.2<br>
4. Compare the text format bytecode of the input and output file (test_pyc.pyc.pyasm, test_pyc.pyc.pyc.pyasm)<br>
5. Check errors during No.4<br>

<p align="center">
<img src="./img/Figure%208.png"><br>
<strong>Figure 8</strong>
<p>
    
Figure 8 epitomizes the failure type and error type of the tools. Total number of test cases is 100, and I tried to use a variety of input files to find diverse errors of the tools. To do this, I selected input files from the popular open-source code (i.e., Torch, Scrapy, Ansible-developer, Scikit-learn, Requests, Youtube-dl, Flask, Micropython, Keras, Luigi, Matplotlib, Speedtest-cli, Pattern). Based on the test result, we might need to find another approach or modify the tools’ source code to some extent.

## Conclusion
For about 2 months, I did set up the development environment, understand the pyc file and the whole concept of the project, and test the tools. Based on the test result, we might need to modify the source code of the tools to meet the concept of our project. In addition, it would be necessary to verify the modified source code exhaustively. When the verification process is complete, we can further to the next step by detecting and modifying the corner case instruction sequence injected by attackers with the reverse engineering. I hope this report could be a cornerstone of future work. I attached all of the detail on Collab Website.

## Reference
[1] PEWNY, J., GARMANY, B., GAWLIK, R., ROSSOW, C., AND HOLZ, T. Cross-Architecture Bug Search in Binary Executables. In Proceedings of the 36th IEEE Symposium on Security and Privacy (S&P’15) (2015).

[2] Andriesse, Dennis, et al. "An in-depth analysis of disassembly on full-scale x86/x64 binaries." 25th {USENIX} Security Symposium ({USENIX} Security 16). 2016.

[3] BALAKRISHNAN, G., AND REPS, T. WYSINWYX: What You See is Not What You eXecute. ACM Transactions on Programming Languages and Systems 32, 6 (Aug. 2010), 23:1–23:84.

[4] MILLER, B. P., AND MENG, X. Binary Code is Not Easy, 2015. Technical report, University of Wisconsin-Madison.

[5] PALEARI, R., MARTIGNONI, L., FRESI ROGLIA, G., AND BRUSCHI, D. N-Version Disassembly: Differential Testing of x86 Disassemblers. In Proceedings of the 19th International Symposium on Software Testing and Analysis (2010), ISSTA’10.

[6] https://github.com/rocky/python-xasm

[7] https://github.com/rocky/python-xdis

[8] https://github.com/rocky/python-uncompyle6

[9] https://towardsdatascience.com/understanding-python-bytecode-e7edaae8734d

[10] http://unpyc.sourceforge.net/Opcodes.html

